[{"id":0,"href":"/","title":"","parent":"","content":" What\u0026rsquo;s this about? The aim of this project is to create a vr game that allows for the basic mechanics of a vr building system including: vr movement, windows, walls, objects (movable in vr) and models must be dynamically loaded into the game.\nWhat does this website contain? This website contains guides on implementing major parts of the game that I have implemented soo far. It also contains advice on where to take certain features further. This is the most complete vr house building guide there is.\nCaution Order of guides\nThe guides on this website are hierarchical in nature: skipping parts may result in errors in the future as each section builds upon the last even if they seem unrelated at times. Prerequisites The guides on this webpage assume a working knowledge of both C# and unity if you are not comfortable working with this you may not understand parts of the guides To learn about C# and unity you may find these guides useful:\nLearn C# Learn Unity Overview The current system consists of the following mechanics:\nCategory Feature VR Basic Setup Movement Objects Importing Objects Picking Up Objects Placing Objects Windows Importing Windows Picking Up Windows Placing Windows Walls Cutting Of Walls UI Selecting Scrolling You can see what it look like in its final form here\n","description":"What\u0026rsquo;s this about? The aim of this project is to create a vr game that allows for the basic mechanics of a vr building system including: vr movement, windows, walls, objects (movable in vr) and models must be dynamically loaded into the game.\nWhat does this website contain? This website contains guides on implementing major parts of the game that I have implemented soo far. It also contains advice on where to take certain features further."},{"id":1,"href":"/Overview.html","title":"Overview","parent":"","content":" What\u0026rsquo;s this about? The aim of this project is to create a vr game that allows for the basic mechanics of a vr building system including: vr movement, windows, walls, objects (movable in vr) and models must be dynamically loaded into the game.\nWhat does this website contain? This website contains guides on implementing major parts of the game that I have implemented soo far. It also contains advice on where to take certain features further. This is the most complete vr house building guide there is.\nCaution Order of guides\nThe guides on this website are hierarchical in nature: skipping parts may result in errors in the future as each section builds upon the last even if they seem unrelated at times. Prerequisites The guides on this webpage assume a working knowledge of both C# and unity if you are not comfortable working with this you may not understand parts of the guides To learn about C# and unity you may find these guides useful:\nLearn C# Learn Unity Overview The current system consists of the following mechanics:\nCategory Feature VR Basic Setup Movement Objects Importing Objects Picking Up Objects Placing Objects Windows Importing Windows Picking Up Windows Placing Windows Walls Cutting Of Walls UI Selecting Scrolling You can see what it look like in its final form here\n","description":"What\u0026rsquo;s this about? The aim of this project is to create a vr game that allows for the basic mechanics of a vr building system including: vr movement, windows, walls, objects (movable in vr) and models must be dynamically loaded into the game.\nWhat does this website contain? This website contains guides on implementing major parts of the game that I have implemented soo far. It also contains advice on where to take certain features further."},{"id":2,"href":"/User-Interface.html","title":"User Interface","parent":"","content":" Overview We need a user interface that the user can interact with to be able to spawn objects into the world; this should incorporate all the objects in the directory and also the names of them.\n","description":"Overview We need a user interface that the user can interact with to be able to spawn objects into the world; this should incorporate all the objects in the directory and also the names of them."},{"id":3,"href":"/Walls.html","title":"Walls","parent":"","content":" Overview Walls need to be able to handle being cut by multiple windows. We\u0026rsquo;re going to use CSG to cut the walls. This cutting will be handled by pbCSG.\n","description":"Overview Walls need to be able to handle being cut by multiple windows. We\u0026rsquo;re going to use CSG to cut the walls. This cutting will be handled by pbCSG."},{"id":4,"href":"/Walls/Creating-Walls.html","title":"Creating Walls","parent":"Walls","content":" Overview Walls need to be able to handle being cut by multiple windows. We\u0026rsquo;re going to use CSG to cut the walls. This cutting will be handled by pbCSG.\nOrginally I was handling walls a different way. You can read about it\nSetup First we will create a class called Wall.\npbCSG creates a new game object when it cuts the object therefore we need to keep track of the current wall and the base wall.\n//The base wall private GameObject baseWall; private MeshRenderer baseWallRend; private Collider wallCollider; //Current wall thats cut private GameObject currentWall; private Collider currentWallCollider; Next we need to keep track of the list of windows that are attached to a window:\nprivate List\u0026lt;Window\u0026gt; windows = new List\u0026lt;Window\u0026gt;(); private Material mat; We will also need a buffer of how much a wall should be in the window so it doesn\u0026rsquo;t work at the very bottom:\nprivate float buffer = 1f; We then need to make a method called Setup() and setup references to these components:\nprivate void Setup() { if(baseWall == null) { baseWall = this.gameObject; } baseWallRend = baseWall.GetComponent\u0026lt;MeshRenderer\u0026gt;(); currentWallCollider = wallCollider = baseWall.GetComponent\u0026lt;Collider\u0026gt;(); } Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; public class Wall : MonoBehaviour { private GameObject baseWall; private MeshRenderer baseWallRend; private Collider wallCollider; private GameObject currentWall; private Collider currentWallCollider; private List\u003cWindow\u003e windows = new List\u003cWindow\u003e(); private Material mat; private float buffer = 1f; void Start() { Setup(); } private void Setup() { if(baseWall == null) { baseWall = this.gameObject; } baseWallRend = baseWall.GetComponent\u003cMeshRenderer\u003e(); currentWallCollider = wallCollider = baseWall.GetComponent\u003cCollider\u003e(); } } ","description":"Overview Walls need to be able to handle being cut by multiple windows. We\u0026rsquo;re going to use CSG to cut the walls. This cutting will be handled by pbCSG.\nOrginally I was handling walls a different way. You can read about it\nSetup First we will create a class called Wall.\npbCSG creates a new game object when it cuts the object therefore we need to keep track of the current wall and the base wall."},{"id":5,"href":"/Windows.html","title":"Windows","parent":"","content":" Overview Windows will be inherited from the object class and will such implement many of the features from the object such as dynmaically creating the colliders and such. However they will not use a grid system as they are different as they must attach to a wall.\n","description":"Overview Windows will be inherited from the object class and will such implement many of the features from the object such as dynmaically creating the colliders and such. However they will not use a grid system as they are different as they must attach to a wall."},{"id":6,"href":"/Windows/Creating-Windows.html","title":"Creating Windows","parent":"Windows","content":" Overview Windows will be inherited from the object class. We\u0026rsquo;re going to need a few things that we didn\u0026rsquo;t need before. We will need to store:\nCollider of the invis and main object The current wall script The mesh object The bounds These will all be used to make a cutout which will be explained later\nWindow Setup We need to make a window class that inherits from the object class and then we need to set it up with additional things shown above.\nCurrent Progress ... public class Window : Object { private Collider col; private Collider invisCol; [SerializeField] public Vector3 size; private float centerBound; public Vector2 fowardBound; private Wall wallScript; [SerializeField] public GameObject MeshObject; private Window windowScript; void Start() { //call object setup Setup(); windowScript = GetComponent\u003cWindow\u003e(); col = GetComponent\u003cCollider\u003e(); invisCol = invis.GetComponent\u003cCollider\u003e(); //These will be used to get the offset on the wall //so that the windows line up properly. size = col.bounds.size; centerBound = col.bounds.center.y; fowardBound = new Vector2(size.z/2,size.x/2); //Find mesh for cutout if(col.GetType().Name.Equals(\"BoxCollider\")) { //a mesh called cutout signifies the mesh is the one that //should be used for cutting Transform temp = transform.Find(\"Scene/cutout\"); // if there isn't one we can just get the top. if(temp == null) { MeshObject = transform.Find(\"Scene\").gameObject.GetComponentsInChildren\u003cTransform\u003e()[1].gameObject; } else { MeshObject = temp.gameObject; } } else { MeshObject = this.gameObject; } } } ","description":"Overview Windows will be inherited from the object class. We\u0026rsquo;re going to need a few things that we didn\u0026rsquo;t need before. We will need to store:\nCollider of the invis and main object The current wall script The mesh object The bounds These will all be used to make a cutout which will be explained later\nWindow Setup We need to make a window class that inherits from the object class and then we need to set it up with additional things shown above."},{"id":7,"href":"/Windows/Handling-Window-Importing.html","title":"Handling Window Importing","parent":"Windows","content":" Overview Current Progress ... using System.Collections; using System.Collections.Generic; using System.IO; using System; using UnityEngine; using GLTFast; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Importer : MonoBehaviour { void ImportAll() { if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \"*.glb\"); foreach(string file in files) { Import(file.Split(\"/\")[^1].Split(\".\")[0]); } } } public async void Import(String file) { byte[] data = File.ReadAllBytes($\"{dirPath}{file}.glb\"); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file).transform; success = await gltf.InstantiateMainSceneAsync( placedModel ); if(success) { GameObject invis = Instantiate(placedModel.gameObject,placedModel.gameObject.transform); invis.gameObject.name = \"Invis\"; Object comp = placedModel.gameObject.AddComponent\u003cObject\u003e(); comp.SetDetails(new ObjectDetails(name,description,type)); comp.SetInvis(invis); comp.leftHand = leftHand; } } } } As you see by our current importing code we do not have a way to handle Windows importing as it only handles importing of Objects. This means we need to design a new way to store data about objects. We\u0026rsquo;re going to use json to store data about objects:\n{ \u0026#34;catalog\u0026#34;: { \u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;, \u0026#34;description\u0026#34;:\u0026#34;description\u0026#34; }, \u0026#34;infomation\u0026#34;: { \u0026#34;type\u0026#34;:\u0026#34;type\u0026#34; } } We should make a class to store these details in. This is just a basic C# class.\nSo in type we can have: Object or Window. We will need: using Newtonsoft.Json.Linq; to be able to parse the json. In Import()\nstring type= \u0026#34;\u0026#34;; if(System.IO.File.Exists($\u0026#34;{dirPath}{file}.json\u0026#34;)) { try { JObject o1 = JObject.Parse(File.ReadAllText($\u0026#34;{dirPath}{file}.json\u0026#34;)); type = (string)o1[\u0026#34;infomation\u0026#34;][\u0026#34;type\u0026#34;]; } catch(Exception e) { Debug.LogError(e); return; } } Additions You can add this\nYou can expand the UI by using the title and the description to improve the UI to have more infomation about a project. We then have the details of the infomation about the object so we can modify the importer to import it.\nif(success) { GameObject invis = Instantiate(placedModel.gameObject,placedModel.gameObject.transform); invis.gameObject.name = \u0026#34;Invis\u0026#34;; if(type == \u0026#34;window\u0026#34;) { Window comp = placedModel.gameObject.AddComponent\u0026lt;Window\u0026gt;(); comp.SetInvis(invis); } else { Object comp = placedModel.gameObject.AddComponent\u0026lt;Object\u0026gt;(); comp.SetInvis(invis); comp.leftHand = leftHand; } } Current Progress ... using System.Collections; using System.Collections.Generic; using System.IO; using System; using UnityEngine; using GLTFast; using Newtonsoft.Json.Linq; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Importer : MonoBehaviour { private string dirPath = $\"C:/Users/{Environment.UserName}/Downloads/stuff/\"; [SerializeField] private bool importEverything = true; [SerializeField] private string fileNames; [SerializeField] private bool forceDetails = true; public InputActionReference leftHand; void Start() { if(importEverything) { ImportAll(); } else { string[] files = fileNames.Split(\",\"); foreach(string fileName in files) { if(fileName != \"\" || fileName != null) { Import(fileName); } } } } public List\u003cstring\u003e GetAllFiles() { List\u003cstring\u003e models = new List\u003cstring\u003e(); if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \"*.glb\"); foreach(string file in files) { models.Add(file.Split(\"/\")[^1].Split(\".\")[0]); } } return models; } public string GetDirPath() { return dirPath; } void ImportAll() { if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \"*.glb\"); foreach(string file in files) { Import(file.Split(\"/\")[^1].Split(\".\")[0]); } } } void ImportAll(List\u003cstring\u003e files) { if(System.IO.Directory.Exists(dirPath)) { foreach(string file in files) { Import(file); } } } public async void Import(String file) { string type= \"\"; if(System.IO.File.Exists($\"{dirPath}{file}.json\")) { try { JObject o1 = JObject.Parse(File.ReadAllText($\"{dirPath}{file}.json\")); type = (string)o1[\"infomation\"][\"type\"]; } catch(Exception e) { if(forceDetails) { Debug.LogError(e); return; } } } else if(forceDetails) { return; } byte[] data = File.ReadAllBytes($\"{dirPath}{file}.glb\"); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file).transform; success = await gltf.InstantiateMainSceneAsync( placedModel ); if(success) { GameObject invis = Instantiate(placedModel.gameObject,placedModel.gameObject.transform); invis.gameObject.name = \"Invis\"; if(type == \"window\") { Window comp = placedModel.gameObject.AddComponent\u003cWindow\u003e(); comp.SetInvis(invis); } else { Object comp = placedModel.gameObject.AddComponent\u003cObject\u003e(); comp.SetInvis(invis); comp.leftHand = leftHand; } } } } } ","description":"Overview Current Progress ... using System.Collections; using System.Collections.Generic; using System.IO; using System; using UnityEngine; using GLTFast; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Importer : MonoBehaviour { void ImportAll() { if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \"*.glb\"); foreach(string file in files) { Import(file.Split(\"/\")[^1].Split(\".\")[0]); } } } public async void Import(String file) { byte[] data = File.ReadAllBytes($\"{dirPath}{file}.glb\"); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file)."},{"id":8,"href":"/Windows/Handling-Windows.html","title":"Handling Windows","parent":"Windows","content":" Overview Current Progress ... public class Window : Object { private Collider col; private Collider invisCol; [SerializeField] public Vector3 size; private float centerBound; public Vector2 fowardBound; private Wall wallScript; [SerializeField] public GameObject MeshObject; private Window windowScript; void Start() { //call object setup Setup(); windowScript = GetComponent\u003cWindow\u003e(); col = GetComponent\u003cCollider\u003e(); invisCol = invis.GetComponent\u003cCollider\u003e(); //These will be used to get the offset on the wall //so that the windows line up properly. size = col.bounds.size; centerBound = col.bounds.center.y; fowardBound = new Vector2(size.z/2,size.x/2); //Find mesh for cutout if(col.GetType().Name.Equals(\"BoxCollider\")) { //a mesh called cutout signifies the mesh is the one that //should be used for cutting Transform temp = transform.Find(\"Scene/cutout\"); // if there isn't one we can just get the top. if(temp == null) { MeshObject = transform.Find(\"Scene\").gameObject.GetComponentsInChildren\u003cTransform\u003e()[1].gameObject; } else { MeshObject = temp.gameObject; } } else { MeshObject = this.gameObject; } } } Handling visuals We need to add an offset to all the windows due to the way blender exports models. Therefore we will override the draw line class with:\npublic override void DrawLine() { line.SetPosition(0,new Vector3(transform.position.x,transform.position.y + centerBound,transform.position.z)); line.SetPosition(1,new Vector3(spot.x,spot.y + centerBound,spot.z)); } State transistion The idea is very similiar to the object SetHeld() method however we need to add and delete windows from the walls list\npublic override void SetHeld() { if(spotValid) { Place(); } else { if(isHeld \u0026amp;\u0026amp; oldWallScript != null) { // go back to the original wall this.gameObject.transform.position = initalPos; transform.rotation = initalRotation; oldWallScript.AddWindow(this.windowScript); oldWallScript.Cut(); } } isHeld = !isHeld; //remove the wall if(isHeld \u0026amp;\u0026amp; oldWallScript != null) { oldWallScript.RemoveWindow(this.windowScript); oldWallScript.Cut(); } //add the correct offset if(this.gameObject.transform.rotation.y == 0 || this.gameObject.transform.rotation.y == 1) { initalPos = new Vector3(transform.position.x,transform.position.y,transform.position.z-fowardBound[0]); } else { if(initalRotation.eulerAngles.y == 90f) { initalPos = new Vector3(transform.position.x-0.05f,transform.position.y,transform.position.z); } else { initalPos = new Vector3(transform.position.x+0.05f,transform.position.y,transform.position.z); } } initalRotation = transform.rotation; ChangeDrawings(isHeld); } Placing windows is just moving the window to the wall and cutting out the window from the wall.\nprivate void Place() { if(!isHeld) return; ChangeDrawings(); gameObject.transform.position = spot; wallScript.AddWindow(this.windowScript); wallScript.Cut(); oldWallScript = wallScript; } Current Progress ... public class Window : Object { private Collider col; private Collider invisCol; [SerializeField] public Vector3 size; private float centerBound; public Vector2 fowardBound; private Wall wallScript; [SerializeField] public GameObject MeshObject; private Window windowScript; void Start() { //call object setup Setup(); windowScript = GetComponent\u003cWindow\u003e(); col = GetComponent\u003cCollider\u003e(); invisCol = invis.GetComponent\u003cCollider\u003e(); //These will be used to get the offset on the wall //so that the windows line up properly. size = col.bounds.size; centerBound = col.bounds.center.y; fowardBound = new Vector2(size.z/2,size.x/2); //Find mesh for cutout if(col.GetType().Name.Equals(\"BoxCollider\")) { //a mesh called cutout signifies the mesh is the one that //should be used for cutting Transform temp = transform.Find(\"Scene/cutout\"); // if there isn't one we can just get the top. if(temp == null) { MeshObject = transform.Find(\"Scene\").gameObject.GetComponentsInChildren\u003cTransform\u003e()[1].gameObject; } else { MeshObject = temp.gameObject; } } else { MeshObject = this.gameObject; } } public override void SetHeld() { if(spotValid) { Place(); } else { if(isHeld \u0026\u0026 oldWallScript != null) { // go back to the original wall this.gameObject.transform.position = initalPos; transform.rotation = initalRotation; oldWallScript.AddWindow(this.windowScript); oldWallScript.Cut(); } } isHeld = !isHeld; //remove the wall if(isHeld \u0026\u0026 oldWallScript != null) { oldWallScript.RemoveWindow(this.windowScript); oldWallScript.Cut(); } //add the correct offset if(this.gameObject.transform.rotation.y == 0 || this.gameObject.transform.rotation.y == 1) { initalPos = new Vector3(transform.position.x,transform.position.y,transform.position.z-fowardBound[0]); } else { if(initalRotation.eulerAngles.y == 90f) { initalPos = new Vector3(transform.position.x-0.05f,transform.position.y,transform.position.z); } else { initalPos = new Vector3(transform.position.x+0.05f,transform.position.y,transform.position.z); } } initalRotation = transform.rotation; ChangeDrawings(isHeld); } public override void DrawLine() { line.SetPosition(0,new Vector3(transform.position.x,transform.position.y + centerBound,transform.position.z)); line.SetPosition(1,new Vector3(spot.x,spot.y + centerBound,spot.z)); } private void Place() { if(!isHeld) return; ChangeDrawings(); gameObject.transform.position = spot; wallScript.AddWindow(this.windowScript); wallScript.Cut(); oldWallScript = wallScript; } } Main loop of a window In the Update() method we check if the object is held and if it isnt we don\u0026rsquo;t run anything: we then check if the invis is too far away from the held object to solve some issues with the system.\nprivate void Update() { if(!isHeld) return; /* this is to stop the invis going really far away probably occurs because of the way the way the valid posistion is calculated in Wall.CalculateClosestPoint() */ if(Vector3.Distance(this.gameObject.transform.position,invis.transform.position) \u0026gt; 10) { invis.transform.position = this.gameObject.transform.position; spotValid = false; } } We then need to calculate the nearest wall to the held object.\n//all walls in a 3f distance Collider[] walls = Physics.OverlapSphere(transform.position, 3f,(1\u0026lt;\u0026lt;7)); GameObject closestObject = null; Wall script = null; float closestWallDist = -1; //for all the walls near the object find the closest one foreach(var wall in walls) { var currentTrans = wall.transform.position; var newDist = Vector3.Distance(transform.position,currentTrans); if(closestWallDist \u0026lt; newDist) { var _script = wall.gameObject.GetComponent\u0026lt;Wall\u0026gt;(); closestObject = wall.gameObject; closestWallDist = newDist; script = _script; this.gameObject.transform.rotation = wall.gameObject.transform.rotation; } } We should check if the walls exist in case they dont for whatever reason.\nif(closestObject != currentWall) { currentWall = closestObject; } if(walls.Length == 0 || closestObject == null) { spot = new Vector3(-.01f,-.01f,-.01f); spotValid = false; ChangeDrawings(false); return; } Then we should find the nearest valid spot on this wall.\nwallScript = script; if(wallScript == null) { wallScript = closestObject.transform.parent.gameObject.GetComponent\u0026lt;Wall\u0026gt;(); } spot = wallScript.CalculateClosestPoint(invis,this.gameObject,invisCol); if(spot.Equals(new Vector3(-.01f,-.01f,-.01f))) { spotValid = false; } else { spotValid = true; } And we should check the validity of the spot and change the drawings depending on that\nif(spotValid) { DrawGuide(); ChangeDrawings(true); } else { ChangeDrawings(false); } Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; public class Window : Object { private Collider col; private Collider invisCol; [SerializeField] public Vector3 size; private float centerBound; public Vector2 fowardBound; private Wall wallScript; private GameObject currentWall; private Wall oldWallScript; [SerializeField] public GameObject MeshObject; private Window windowScript; void Start() { Setup(); windowScript = GetComponent\u003cWindow\u003e(); //this doesnt seem right but ii cant find method for doing it col = GetComponent\u003cCollider\u003e(); invisCol = invis.GetComponent\u003cCollider\u003e(); size = col.bounds.size; centerBound = col.bounds.center.y; fowardBound = new Vector2(size.z/2,size.x/2); if(col.GetType().Name.Equals(\"BoxCollider\")) { Transform temp = transform.Find(\"Scene/cutout\"); if(temp == null) { MeshObject = transform.Find(\"Scene\").gameObject.GetComponentsInChildren\u003cTransform\u003e()[1].gameObject; } else { MeshObject = temp.gameObject; } } else { MeshObject = this.gameObject; } } private void Update() { /* this is to stop the invis going really far away probably occurs because of the way the way the valid posistion is calculated in Wall.CalculateClosestPoint() */ if(Vector3.Distance(this.gameObject.transform.position,invis.transform.position) \u003e 10) { invis.transform.position = this.gameObject.transform.position; spotValid = false; } if(!isHeld) return; Collider[] walls = Physics.OverlapSphere(transform.position, 3f,(1\u003c\u003c7)); GameObject closestObject = null; Wall script = null; float closestWallDist = -1; foreach(var wall in walls) { var currentTrans = wall.transform.position; var newDist = Vector3.Distance(transform.position,currentTrans); if(closestWallDist \u003c newDist) { var _script = wall.gameObject.GetComponent\u003cWall\u003e(); closestObject = wall.gameObject; closestWallDist = newDist; script = _script; this.gameObject.transform.rotation = wall.gameObject.transform.rotation; } } if(closestObject != currentWall) { currentWall = closestObject; } if(walls.Length == 0 || closestObject == null) { spot = new Vector3(-.01f,-.01f,-.01f); spotValid = false; ChangeDrawings(false); return; } wallScript = script; if(wallScript == null) { wallScript = closestObject.transform.parent.gameObject.GetComponent\u003cWall\u003e(); } spot = wallScript.CalculateClosestPoint(invis,this.gameObject,invisCol); if(spot.Equals(new Vector3(-.01f,-.01f,-.01f))) { spotValid = false; } else { spotValid = true; } if(spotValid) { DrawGuide(); ChangeDrawings(true); } else { ChangeDrawings(false); } } private void Place() { if(!isHeld) return; ChangeDrawings(); gameObject.transform.position = spot; wallScript.AddWindow(this.windowScript); wallScript.Cut(); oldWallScript = wallScript; } public override void DrawLine() { line.SetPosition(0,new Vector3(transform.position.x,transform.position.y + centerBound,transform.position.z)); line.SetPosition(1,new Vector3(spot.x,spot.y + centerBound,spot.z)); } public override void SetHeld() { if(spotValid) { Place(); } else { if(isHeld \u0026\u0026 oldWallScript != null) { this.gameObject.transform.position = initalPos; transform.rotation = initalRotation; oldWallScript.AddWindow(this.windowScript); oldWallScript.Cut(); } } isHeld = !isHeld; if(isHeld \u0026\u0026 oldWallScript != null) { oldWallScript.RemoveWindow(this.windowScript); oldWallScript.Cut(); } if(this.gameObject.transform.rotation.y == 0 || this.gameObject.transform.rotation.y == 1) { initalPos = new Vector3(transform.position.x,transform.position.y,transform.position.z-fowardBound[0]); } else { if(initalRotation.eulerAngles.y == 90f) { initalPos = new Vector3(transform.position.x-0.05f,transform.position.y,transform.position.z); } else { initalPos = new Vector3(transform.position.x+0.05f,transform.position.y,transform.position.z); } } initalRotation = transform.rotation; ChangeDrawings(isHeld); } } ","description":"Overview Current Progress ... public class Window : Object { private Collider col; private Collider invisCol; [SerializeField] public Vector3 size; private float centerBound; public Vector2 fowardBound; private Wall wallScript; [SerializeField] public GameObject MeshObject; private Window windowScript; void Start() { //call object setup Setup(); windowScript = GetComponent(); col = GetComponent(); invisCol = invis.GetComponent(); //These will be used to get the offset on the wall //so that the windows line up properly."},{"id":9,"href":"/Objects/Creating-Grid-System.html","title":"Creating Grid System","parent":"Unity Setup","content":" Overview We have an object and we want to get the closest grid point to the object.\nA grid is essentially a collection of points in space equally spaced apart.\nFirst we will calculate the nearest point on the grid by: taking a position in the world and returning the nearest point on the grid to that position. It does this by subtracting the grid\u0026rsquo;s position from the input position, rounding the resulting x and z coordinates to the nearest integer multiple of the grid size, and then adding the grid\u0026rsquo;s position back to get the final point on the grid.\nprivate float size = 1f; //SIZE OF THE GRID public Vector3 GetNearestPoint(Vector3 pos) { pos -= transform.position; int xCount = Mathf.RoundToInt(pos.x/size); int zCount = Mathf.RoundToInt(pos.z/size); Vector3 result = new Vector3((float)xCount*size,0,(float)zCount*size); result += transform.position; return result; } We then need to handle checking if the spot is valid. We do this by making a physics overlap sphere at the point and seeing if it collides with anything that it is not meant to collide with.\npublic bool GetValidityPos(Vector3 pos, Vector3 playerPos, GameObject invis = null) { if(pos.x == -0.1f) { return false; } if(invis == null) { Collider[] groundHitColliders = Physics.OverlapSphere(pos, 0.25f,(1\u0026lt;\u0026lt;31)); if(groundHitColliders.Length == 0) { return false; } Collider[] hitColliders = Physics.OverlapSphere(pos, 0.25f,(1\u0026lt;\u0026lt;6)); if(hitColliders.Length != 0) { return false; } Collider[] wallHitColliders = Physics.OverlapSphere(pos, 0.25f,(1\u0026lt;\u0026lt;7)); if(wallHitColliders.Length != 0) { return false; } if (Physics.Linecast (playerPos,pos,out RaycastHit hitInfo,(1\u0026lt;\u0026lt;7))) { return false; } return true; } return false; } Additions You can add this\nThis could can be further optimised by only performing the Physics.OverlapSphere once on all layers and going through and checking the layers. We can then use these in conjunction with a new method to calculate the nearest point on the grid:\npublic Vector3 GetNearestValidPoint(Vector3 pos) { Vector3 newPos = GetNearestPoint(pos); if(GetValidityPos(newPos,pos)) { return newPos; } for(int x = -1; x \u0026lt; 2; x++) { for(int z =-1; z \u0026lt; 2; z++) { newPos = GetNearestPoint(new Vector3(pos.x+x,pos.y,pos.z+z)); if(GetValidityPos(newPos,pos)) { return newPos; } } } return new Vector3(-0.1f,-0.1f,-0.1f); } This method takes a position in the world and returns the nearest valid point on the grid to that position. It first calls the GetNearestPoint method to find the nearest point on the grid, and then calls the GetValidityPos method to check if that point is valid. If the point is valid, it is returned. Otherwise, the method checks the eight adjacent points to the nearest point on the grid (i.e. the points with x and z coordinates +/-1 from the nearest point) and returns the first valid point it finds. If it doesn\u0026rsquo;t find one it returns a Vector3 with x, y, and z coordinates of -0.1f.\nObject is o it checks x:\n-1 0 1 x x x x o x x x x Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; public class Grid : MonoBehaviour { [SerializeField] private float size = 1f; public Vector3 GetNearestPoint(Vector3 pos) { pos -= transform.position; int xCount = Mathf.RoundToInt(pos.x/size); int zCount = Mathf.RoundToInt(pos.z/size); Vector3 result = new Vector3((float)xCount*size,0,(float)zCount*size); result += transform.position; return result; } public bool GetValidityPos(Vector3 pos, Vector3 playerPos, GameObject invis = null) { if(pos.x == -0.1f) { return false; } if(invis == null) { Collider[] groundHitColliders = Physics.OverlapSphere(pos, 0.25f,(1\u003c\u003c31)); if(groundHitColliders.Length == 0) { return false; } Collider[] hitColliders = Physics.OverlapSphere(pos, 0.25f,(1\u003c\u003c6)); if(hitColliders.Length != 0) { return false; } Collider[] wallHitColliders = Physics.OverlapSphere(pos, 0.25f,(1\u003c\u003c7)); if(wallHitColliders.Length != 0) { return false; } if (Physics.Linecast (playerPos,pos,out RaycastHit hitInfo,(1\u003c\u003c7))) { return false; } return true; } return false; } /* Checks # ### #o# ### */ public Vector3 GetNearestValidPoint(Vector3 pos,int max = 10000) { Vector3 newPos = GetNearestPoint(pos); if(GetValidityPos(newPos,pos)) { return newPos; } for(int x = -1; x \u003c 2; x++) { for(int z =-1; z \u003c 2; z++) { newPos = GetNearestPoint(new Vector3(pos.x+x,pos.y,pos.z+z)); if(GetValidityPos(newPos,pos)) { return newPos; } } } return new Vector3(-0.1f,-0.1f,-0.1f); } } ","description":"Overview We have an object and we want to get the closest grid point to the object.\nA grid is essentially a collection of points in space equally spaced apart.\nFirst we will calculate the nearest point on the grid by: taking a position in the world and returning the nearest point on the grid to that position. It does this by subtracting the grid\u0026rsquo;s position from the input position, rounding the resulting x and z coordinates to the nearest integer multiple of the grid size, and then adding the grid\u0026rsquo;s position back to get the final point on the grid."},{"id":10,"href":"/Objects/Creating-Objects.html","title":"Creating Objects","parent":"Unity Setup","content":" Overview Objects cosist of two main states: held and placed\nHeld What does a held object do Draws a line to valid spot Draws a transparent Object at valid spot Follow controller Go to spot when placed and a placed object should just be able to transistion into the held state.\nObject Setup Create a method: protected void Setup() We\u0026rsquo;ll make it protected so it can be called by the window class when we are creating it. We should also add gameObject.layer = 6; into this method and make layer 6 in unity be Object.\nSetting the invis object First we need to get a reference to the invis and a method for setting it:\nprotected GameObject invis; public bool SetInvis(GameObject invis) { if(this.invis == null) { this.invis = invis; return true; } return false; } Then in the Setup() method we loop through all the meshes and give them the green texture\nMaterial green = (Material)Resources.Load(\u0026#34;GREEN\u0026#34;, typeof(Material)); //sometimes there is one mesh if(invis.TryGetComponent(out MeshRenderer mRend)) { mRend.material = green; } //sometimes there are children meshes MeshRenderer[] MeshRenderers = invis.GetComponentsInChildren\u0026lt;MeshRenderer\u0026gt;(true); if(MeshRenderers.Length != 0) { foreach(MeshRenderer mRendr in MeshRenderers) { mRendr.material = green; } } //no object is held invis.SetActive(false); Resources.Load() Is a method in unity to read load an asset stored in the resources path: documentation\nTherefore you should create a folder in the project called Resources and make a material called GREEN there to be loaded.\nCurrent Progress ... public class Object : MonoBehaviour { protected GameObject invis; public bool SetInvis(GameObject invis) { if(this.invis == null) { this.invis = invis; return true; } return false; } protected void Setup() { gameObject.layer = 6; Material green = (Material)Resources.Load(\"GREEN\", typeof(Material)); //sometimes there is one mesh if(invis.TryGetComponent(out MeshRenderer mRend)) { mRend.material = green; } //sometimes there are children meshes MeshRenderer[] MeshRenderers = invis.GetComponentsInChildren\u003cMeshRenderer\u003e(true); if(MeshRenderers.Length != 0) { foreach(MeshRenderer mRendr in MeshRenderers) { mRendr.material = green; } } //no object is held invis.SetActive(false); } } Setting up the line renderer Add a requirement of a LineRenderer to the script:\n[RequireComponent(typeof(LineRenderer))] public class Object : MonoBehaviour This will automatically add a line renderer to the object.\nSo we\u0026rsquo;ll add a reference to this object:\nprotected LineRenderer line; and set this reference in the awake method:\nvoid Awake() { line = GetComponent\u0026lt;LineRenderer\u0026gt;(); } In Setup() we can then set up the line renderer:\n//SETUP LINE RENDERER line.enabled = false; line.startWidth = 0.1059608f; line.endWidth = 0.1059608f; These two values for width are personal peference and can be tweaked to your liking.\nCurrent Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; public class Object : MonoBehaviour { protected GameObject invis; protected LineRenderer line; void Awake() { line = GetComponent\u003cLineRenderer\u003e(); } public bool SetInvis(GameObject invis) { if(this.invis == null) { this.invis = invis; return true; } return false; } protected void Setup() { gameObject.layer = 6; Material green = (Material)Resources.Load(\"GREEN\", typeof(Material)); //sometimes there is one mesh if(invis.TryGetComponent(out MeshRenderer mRend)) { mRend.material = green; } //sometimes there are children meshes MeshRenderer[] MeshRenderers = invis.GetComponentsInChildren\u003cMeshRenderer\u003e(true); if(MeshRenderers.Length != 0) { foreach(MeshRenderer mRendr in MeshRenderers) { mRendr.material = green; } } //no object is held invis.SetActive(false); //SETUP LINE RENDERER line.enabled = false; line.startWidth = 0.1059608f; line.endWidth = 0.1059608f; } } Adding colliders to an object Since we are dynmically loading in objects we need to implement a method for creating the collider for the object:\nprivate void CreateColliders(GameObject objectToUse, int mshFilterLength = 2) { if(objectToUse.TryGetComponent(out MeshFilter meshF)) { MeshCollider mCol = objectToUse.AddComponent\u0026lt;MeshCollider\u0026gt;(); mCol.sharedMesh = meshF.mesh; } else { MeshFilter[] mshFilters = objectToUse.GetComponentsInChildren\u0026lt;MeshFilter\u0026gt;(true); if(mshFilters.Length == mshFilterLength) { MeshCollider mCol = objectToUse.AddComponent\u0026lt;MeshCollider\u0026gt;(); mCol.sharedMesh = mshFilters[0].mesh; } else { Transform meshes = transform.Find(\u0026#34;Scene\u0026#34;); AddColliderAroundChildren(meshes.gameObject,objectToUse); } } } All this does is check if the there is multiple meshes or a single mesh: one mesh means we can use a mesh collider else we need to calculate the bounds using a different method which takes into account:\nprivate Collider AddColliderAroundChildren(GameObject assetModel, GameObject boxModel = null) { if(boxModel == null) { boxModel = assetModel; } /* Store the initial position, rotation, and scale of the assetModel GameObject. */ var pos = assetModel.transform.localPosition; var rot = assetModel.transform.localRotation; var scale = assetModel.transform.localScale; /* Next, reset the assetModel transform to zero position, no rotation, and scale of one. This is done to ensure that the object\u0026#39;s bounds are properly calculated. */ assetModel.transform.localPosition = Vector3.zero; assetModel.transform.localRotation = Quaternion.identity; assetModel.transform.localScale = Vector3.one; var bounds = new Bounds(Vector3.zero, Vector3.zero); if (assetModel.transform.TryGetComponent\u0026lt;Renderer\u0026gt;(out var mainRenderer)) { bounds = mainRenderer.bounds; } /* Retrieve all the descendant transforms of assetModel using the GetComponentsInChildren method. For each of the descendant transforms that have a Renderer component, the bounds of the renderer are added to bounds using the Encapsulate method. */ var descendants = assetModel.GetComponentsInChildren\u0026lt;Transform\u0026gt;(); foreach (Transform desc in descendants) { if(desc.gameObject.name == \u0026#34;EXCLUDE\u0026#34;) { continue; } if (desc.TryGetComponent\u0026lt;Renderer\u0026gt;(out var childRenderer)) { //if initialized to renderer bounds yet if (bounds.extents == Vector3.zero) bounds = childRenderer.bounds; bounds.Encapsulate(childRenderer.bounds); } } /* After calculating the bounds, the method adds a BoxCollider component to boxModel and sets its center and size properties based on the bounds and position of the assetModel. */ var boxCol = boxModel.AddComponent\u0026lt;BoxCollider\u0026gt;(); boxCol.center = bounds.center - assetModel.transform.position; boxCol.size = bounds.size; // restore transforms assetModel.transform.localPosition = pos; assetModel.transform.localRotation = rot; assetModel.transform.localScale = scale; return boxCol; } We can then call them in the Setup() function:\nCreateColliders(gameObject); CreateColliders(invis,1); Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; public class Object : MonoBehaviour { protected GameObject invis; protected LineRenderer line; void Awake() { line = GetComponent\u003cLineRenderer\u003e(); } public bool SetInvis(GameObject invis) { if(this.invis == null) { this.invis = invis; return true; } return false; } private void CreateColliders(GameObject objectToUse, int mshFilterLength = 2) { if(objectToUse.TryGetComponent(out MeshFilter meshF)) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = meshF.mesh; } else { MeshFilter[] mshFilters = objectToUse.GetComponentsInChildren\u003cMeshFilter\u003e(true); if(mshFilters.Length == mshFilterLength) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = mshFilters[0].mesh; } else { Transform meshes = transform.Find(\"Scene\"); AddColliderAroundChildren(meshes.gameObject,objectToUse); } } } private Collider AddColliderAroundChildren(GameObject assetModel, GameObject boxModel = null) { if(boxModel == null) { boxModel = assetModel; } var pos = assetModel.transform.localPosition; var rot = assetModel.transform.localRotation; var scale = assetModel.transform.localScale; assetModel.transform.localPosition = Vector3.zero; assetModel.transform.localRotation = Quaternion.identity; assetModel.transform.localScale = Vector3.one; var bounds = new Bounds(Vector3.zero, Vector3.zero); if (assetModel.transform.TryGetComponent\u003cRenderer\u003e(out var mainRenderer)) { bounds = mainRenderer.bounds; } var descendants = assetModel.GetComponentsInChildren\u003cTransform\u003e(); foreach (Transform desc in descendants) { if(desc.gameObject.name == \"EXCLUDE\") { continue; } if (desc.TryGetComponent\u003cRenderer\u003e(out var childRenderer)) { if (bounds.extents == Vector3.zero) bounds = childRenderer.bounds; bounds.Encapsulate(childRenderer.bounds); } } var boxCol = boxModel.AddComponent\u003cBoxCollider\u003e(); boxCol.center = bounds.center - assetModel.transform.position; boxCol.size = bounds.size; assetModel.transform.localPosition = pos; assetModel.transform.localRotation = rot; assetModel.transform.localScale = scale; return boxCol; } protected void Setup() { gameObject.layer = 6; Material green = (Material)Resources.Load(\"GREEN\", typeof(Material)); //sometimes there is one mesh if(invis.TryGetComponent(out MeshRenderer mRend)) { mRend.material = green; } //sometimes there are children meshes MeshRenderer[] MeshRenderers = invis.GetComponentsInChildren\u003cMeshRenderer\u003e(true); if(MeshRenderers.Length != 0) { foreach(MeshRenderer mRendr in MeshRenderers) { mRendr.material = green; } } //no object is held invis.SetActive(false); //SETUP LINE RENDERER line.enabled = false; line.startWidth = 0.1059608f; line.endWidth = 0.1059608f; CreateColliders(gameObject); CreateColliders(invis,1); } } Setting Up Objects As Interactables Add name spaces to use vr interactions:\nusing UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; Next in the Setup() we should make it so that the object is not threw when detached from the object as we will be handling the placing with a grid system. We should also not be tracking the rotation of the controller as it will also be handled by the grid system. We also need to add listeners to allow for methods to be called on pick up and drop\nvar xrG = gameObject.AddComponent\u0026lt;XRGrabInteractable\u0026gt;(); xrG.throwOnDetach = false; xrG.trackRotation = false; xrG.selectEntered.AddListener(OnSelectEntered); xrG.selectExited.AddListener(OnSelectExited); xrG.movementType = XRBaseInteractable.MovementType.Instantaneous; Add the listeners outside the method as well:\nprotected virtual void OnSelectEntered(SelectEnterEventArgs args) =\u0026gt; SetHeld(); protected virtual void OnSelectExited(SelectExitEventArgs args) =\u0026gt; SetHeld(); We don\u0026rsquo;t have a method for SetHeld() yet so we\u0026rsquo;ll create that to avoid errors\npublic virtual void SetHeld() { } Adding the grid system We first add a variable for the grid system.\nprivate Grid grid; and then we set this grid reference in the awake method\nvoid Awake() { line = GetComponent\u0026lt;LineRenderer\u0026gt;(); grid = GetComponent\u0026lt;Grid\u0026gt;(); } Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Object : MonoBehaviour { protected GameObject invis; protected LineRenderer line; private Grid grid; void Awake() { line = GetComponent\u003cLineRenderer\u003e(); grid = GetComponent\u003cGrid\u003e(); } public bool SetInvis(GameObject invis) { if(this.invis == null) { this.invis = invis; return true; } return false; } private void CreateColliders(GameObject objectToUse, int mshFilterLength = 2) { if(objectToUse.TryGetComponent(out MeshFilter meshF)) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = meshF.mesh; } else { MeshFilter[] mshFilters = objectToUse.GetComponentsInChildren\u003cMeshFilter\u003e(true); if(mshFilters.Length == mshFilterLength) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = mshFilters[0].mesh; } else { Transform meshes = transform.Find(\"Scene\"); AddColliderAroundChildren(meshes.gameObject,objectToUse); } } } private Collider AddColliderAroundChildren(GameObject assetModel, GameObject boxModel = null) { if(boxModel == null) { boxModel = assetModel; } var pos = assetModel.transform.localPosition; var rot = assetModel.transform.localRotation; var scale = assetModel.transform.localScale; assetModel.transform.localPosition = Vector3.zero; assetModel.transform.localRotation = Quaternion.identity; assetModel.transform.localScale = Vector3.one; var bounds = new Bounds(Vector3.zero, Vector3.zero); if (assetModel.transform.TryGetComponent\u003cRenderer\u003e(out var mainRenderer)) { bounds = mainRenderer.bounds; } var descendants = assetModel.GetComponentsInChildren\u003cTransform\u003e(); foreach (Transform desc in descendants) { if(desc.gameObject.name == \"EXCLUDE\") { continue; } if (desc.TryGetComponent\u003cRenderer\u003e(out var childRenderer)) { if (bounds.extents == Vector3.zero) bounds = childRenderer.bounds; bounds.Encapsulate(childRenderer.bounds); } } var boxCol = boxModel.AddComponent\u003cBoxCollider\u003e(); boxCol.center = bounds.center - assetModel.transform.position; boxCol.size = bounds.size; assetModel.transform.localPosition = pos; assetModel.transform.localRotation = rot; assetModel.transform.localScale = scale; return boxCol; } protected void Setup() { gameObject.layer = 6; Material green = (Material)Resources.Load(\"GREEN\", typeof(Material)); //sometimes there is one mesh if(invis.TryGetComponent(out MeshRenderer mRend)) { mRend.material = green; } //sometimes there are children meshes MeshRenderer[] MeshRenderers = invis.GetComponentsInChildren\u003cMeshRenderer\u003e(true); if(MeshRenderers.Length != 0) { foreach(MeshRenderer mRendr in MeshRenderers) { mRendr.material = green; } } //no object is held invis.SetActive(false); //SETUP LINE RENDERER line.enabled = false; line.startWidth = 0.1059608f; line.endWidth = 0.1059608f; CreateColliders(gameObject); CreateColliders(invis,1); var xrG = gameObject.AddComponent\u003cXRGrabInteractable\u003e(); xrG.throwOnDetach = false; xrG.trackRotation = false; xrG.selectEntered.AddListener(OnSelectEntered); xrG.selectExited.AddListener(OnSelectExited); xrG.movementType = XRBaseInteractable.MovementType.Instantaneous; } public virtual void SetHeld() { } } ","description":"Overview Objects cosist of two main states: held and placed\nHeld What does a held object do Draws a line to valid spot Draws a transparent Object at valid spot Follow controller Go to spot when placed and a placed object should just be able to transistion into the held state.\nObject Setup Create a method: protected void Setup() We\u0026rsquo;ll make it protected so it can be called by the window class when we are creating it."},{"id":11,"href":"/Objects/Handling-Objects.html","title":"Handling Objects","parent":"Unity Setup","content":" Overview Held What does a held object do Draws a line to valid spot Draws a transparent Object at valid spot Follow controller Go to spot when placed Overview of what we will do Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Object : MonoBehaviour { protected GameObject invis; protected LineRenderer line; void Awake() { line = GetComponent\u003cLineRenderer\u003e(); grid = GetComponent\u003cGrid\u003e(); } public bool SetInvis(GameObject invis) { if(this.invis == null) { this.invis = invis; return true; } return false; } private void CreateColliders(GameObject objectToUse, int mshFilterLength = 2) { if(objectToUse.TryGetComponent(out MeshFilter meshF)) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = meshF.mesh; } else { MeshFilter[] mshFilters = objectToUse.GetComponentsInChildren\u003cMeshFilter\u003e(true); if(mshFilters.Length == mshFilterLength) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = mshFilters[0].mesh; } else { Transform meshes = transform.Find(\"Scene\"); AddColliderAroundChildren(meshes.gameObject,objectToUse); } } } private Collider AddColliderAroundChildren(GameObject assetModel, GameObject boxModel = null) { if(boxModel == null) { boxModel = assetModel; } var pos = assetModel.transform.localPosition; var rot = assetModel.transform.localRotation; var scale = assetModel.transform.localScale; assetModel.transform.localPosition = Vector3.zero; assetModel.transform.localRotation = Quaternion.identity; assetModel.transform.localScale = Vector3.one; var bounds = new Bounds(Vector3.zero, Vector3.zero); if (assetModel.transform.TryGetComponent\u003cRenderer\u003e(out var mainRenderer)) { bounds = mainRenderer.bounds; } var descendants = assetModel.GetComponentsInChildren\u003cTransform\u003e(); foreach (Transform desc in descendants) { if(desc.gameObject.name == \"EXCLUDE\") { continue; } if (desc.TryGetComponent\u003cRenderer\u003e(out var childRenderer)) { if (bounds.extents == Vector3.zero) bounds = childRenderer.bounds; bounds.Encapsulate(childRenderer.bounds); } } var boxCol = boxModel.AddComponent\u003cBoxCollider\u003e(); boxCol.center = bounds.center - assetModel.transform.position; boxCol.size = bounds.size; assetModel.transform.localPosition = pos; assetModel.transform.localRotation = rot; assetModel.transform.localScale = scale; return boxCol; } protected void Setup() { gameObject.layer = 6; Material green = (Material)Resources.Load(\"GREEN\", typeof(Material)); //sometimes there is one mesh if(invis.TryGetComponent(out MeshRenderer mRend)) { mRend.material = green; } //sometimes there are children meshes MeshRenderer[] MeshRenderers = invis.GetComponentsInChildren\u003cMeshRenderer\u003e(true); if(MeshRenderers.Length != 0) { foreach(MeshRenderer mRendr in MeshRenderers) { mRendr.material = green; } } //no object is held invis.SetActive(false); //SETUP LINE RENDERER line.enabled = false; line.startWidth = 0.1059608f; line.endWidth = 0.1059608f; CreateColliders(gameObject); CreateColliders(invis,1); var xrG = gameObject.AddComponent\u003cXRGrabInteractable\u003e(); xrG.throwOnDetach = false; xrG.trackRotation = false; xrG.selectEntered.AddListener(OnSelectEntered); xrG.selectExited.AddListener(OnSelectExited); xrG.movementType = XRBaseInteractable.MovementType.Instantaneous; } public virtual void SetHeld() { } } State Transistions First we are going to handle transistioning between held and not held.\nHandling Guides First we need to make a method to turn off the line renderer and the invis if the object is not held.\nprotected void ChangeDrawings() { invis.SetActive(!invis.activeSelf); line.enabled = !line.enabled; } protected void ChangeDrawings(bool value) { invis.SetActive(value); line.enabled = value; } This will change the state of the guides.\nHandling State Transistion Handle guides and state First we need to implement a boolean to let the object know what state it is:\nprotected bool isHeld; We then can set this in the function and also change the state of the guides we made earlier called SetHeld():\npublic virtual void SetHeld() { isHeld = !isHeld; ChangeDrawings(isHeld); } Handle position An object needs to check if there is a valid spot and if there is it should go to that spot. Else it should go to the previous spot the object was occupying.\nFirst let\u0026rsquo;s create the variables we need:\nprotected bool spotValid; protected Vector3 spot; protected Vector3 initalPos; protected Quaternion initalRotation; And the method for handling them:\npublic virtual void SetHeld() { //if spot is valid place. if(!(spotValid \u0026amp;\u0026amp; Place())) { if(initalPos != null \u0026amp;\u0026amp; initalRotation != null) { //go to the inital posistion transform.position = initalPos; transform.rotation = initalRotation; } else { Destroy(this.gameObject) } } isHeld = !isHeld; ChangeDrawings(isHeld); if(isHeld) { initalPos = transform.position; initalRotation = transform.rotation; } } private bool Place() { if(!isHeld) return false; transform.position = spot; return true; } This will handle the position changes when picked up and placed down.\nCurrent Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Object : MonoBehaviour { protected GameObject invis; protected LineRenderer line; protected bool spotValid; protected Vector3 spot; protected Vector3 initalPos; protected Quaternion initalRotation; private Grid grid; protected bool isHeld; void Awake() { line = GetComponent\u003cLineRenderer\u003e(); grid = GetComponent\u003cGrid\u003e(); } public bool SetInvis(GameObject invis) { if(this.invis == null) { this.invis = invis; return true; } return false; } private void CreateColliders(GameObject objectToUse, int mshFilterLength = 2) { if(objectToUse.TryGetComponent(out MeshFilter meshF)) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = meshF.mesh; } else { MeshFilter[] mshFilters = objectToUse.GetComponentsInChildren\u003cMeshFilter\u003e(true); if(mshFilters.Length == mshFilterLength) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = mshFilters[0].mesh; } else { Transform meshes = transform.Find(\"Scene\"); AddColliderAroundChildren(meshes.gameObject,objectToUse); } } } private Collider AddColliderAroundChildren(GameObject assetModel, GameObject boxModel = null) { if(boxModel == null) { boxModel = assetModel; } var pos = assetModel.transform.localPosition; var rot = assetModel.transform.localRotation; var scale = assetModel.transform.localScale; assetModel.transform.localPosition = Vector3.zero; assetModel.transform.localRotation = Quaternion.identity; assetModel.transform.localScale = Vector3.one; var bounds = new Bounds(Vector3.zero, Vector3.zero); if (assetModel.transform.TryGetComponent\u003cRenderer\u003e(out var mainRenderer)) { bounds = mainRenderer.bounds; } var descendants = assetModel.GetComponentsInChildren\u003cTransform\u003e(); foreach (Transform desc in descendants) { if(desc.gameObject.name == \"EXCLUDE\") { continue; } if (desc.TryGetComponent\u003cRenderer\u003e(out var childRenderer)) { if (bounds.extents == Vector3.zero) bounds = childRenderer.bounds; bounds.Encapsulate(childRenderer.bounds); } } var boxCol = boxModel.AddComponent\u003cBoxCollider\u003e(); boxCol.center = bounds.center - assetModel.transform.position; boxCol.size = bounds.size; assetModel.transform.localPosition = pos; assetModel.transform.localRotation = rot; assetModel.transform.localScale = scale; return boxCol; } protected void Setup() { gameObject.layer = 6; Material green = (Material)Resources.Load(\"GREEN\", typeof(Material)); //sometimes there is one mesh if(invis.TryGetComponent(out MeshRenderer mRend)) { mRend.material = green; } //sometimes there are children meshes MeshRenderer[] MeshRenderers = invis.GetComponentsInChildren\u003cMeshRenderer\u003e(true); if(MeshRenderers.Length != 0) { foreach(MeshRenderer mRendr in MeshRenderers) { mRendr.material = green; } } //no object is held invis.SetActive(false); //SETUP LINE RENDERER line.enabled = false; line.startWidth = 0.1059608f; line.endWidth = 0.1059608f; CreateColliders(gameObject); CreateColliders(invis,1); var xrG = gameObject.AddComponent\u003cXRGrabInteractable\u003e(); xrG.throwOnDetach = false; xrG.trackRotation = false; xrG.selectEntered.AddListener(OnSelectEntered); xrG.selectExited.AddListener(OnSelectExited); xrG.movementType = XRBaseInteractable.MovementType.Instantaneous; } public virtual void SetHeld() { //if spot is valid place. if(!(spotValid \u0026\u0026 Place())) { if(initalPos != null \u0026\u0026 initalRotation != null) { //go to the inital posistion transform.position = initalPos; transform.rotation = initalRotation; } else { Destroy(this.gameObject); } } isHeld = !isHeld; ChangeDrawings(isHeld); if(isHeld) { initalPos = transform.position; initalRotation = transform.rotation; } } private bool Place() { if(!isHeld) return false; transform.position = spot; return true; } } Handling the Held state Overview of Held State Held objects will check to find the nearest valid spot on the grid and they will draw a line from the held object to this valid spot and draw a green object there to show what it will look like.\nHandle Guides First thing we need to implement is the drawings of the guides to the spot on the grid where the object needs to go.\npublic virtual void DrawLine() { line.SetPosition(0,transform.position); line.SetPosition(1,spot); } private void DrawInvis() { invis.transform.position = spot; } For ease of use we will group these functions in another function.\nprotected void DrawGuide() { DrawLine(); DrawInvis(); } Main loop of an object First we will add a rotation method so we can rotate game objects:\nprivate void Rotate(float angle = 45f) { transform.rotation = transform.rotation * Quaternion.Euler(0, angle, 0); } We just get the nearest spot to a held object and check if it\u0026rsquo;s valid and if it is we draw a line to it. We also allow for object rotation: this will need a reference to the controller so we need to add: using UnityEngine.XR.Interaction.Toolkit; and also the variable: public InputActionReference leftHand;\nvoid Update() { if(!isHeld) return; //check spot validity spot = grid.GetNearestValidPoint(transform.position); spotValid = grid.GetValidityPos(spot,this.gameObject.transform.position); ChangeDrawings(spotValid); if(spotValid) { DrawGuide(); } float controllerValue = leftHand.action.ReadValue\u0026lt;Vector2\u0026gt;().x; if(Mathf.Abs(controllerValue) == 1) { Rotate(45*controllerValue); } } Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Object : MonoBehaviour { protected GameObject invis; protected LineRenderer line; protected bool spotValid; protected Vector3 spot; protected Vector3 initalPos; protected Quaternion initalRotation; private Grid grid; protected bool isHeld; void Awake() { line = GetComponent\u003cLineRenderer\u003e(); grid = GetComponent\u003cGrid\u003e(); } public bool SetInvis(GameObject invis) { if(this.invis == null) { this.invis = invis; return true; } return false; } private void CreateColliders(GameObject objectToUse, int mshFilterLength = 2) { if(objectToUse.TryGetComponent(out MeshFilter meshF)) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = meshF.mesh; } else { MeshFilter[] mshFilters = objectToUse.GetComponentsInChildren\u003cMeshFilter\u003e(true); if(mshFilters.Length == mshFilterLength) { MeshCollider mCol = objectToUse.AddComponent\u003cMeshCollider\u003e(); mCol.sharedMesh = mshFilters[0].mesh; } else { Transform meshes = transform.Find(\"Scene\"); AddColliderAroundChildren(meshes.gameObject,objectToUse); } } } private Collider AddColliderAroundChildren(GameObject assetModel, GameObject boxModel = null) { if(boxModel == null) { boxModel = assetModel; } var pos = assetModel.transform.localPosition; var rot = assetModel.transform.localRotation; var scale = assetModel.transform.localScale; assetModel.transform.localPosition = Vector3.zero; assetModel.transform.localRotation = Quaternion.identity; assetModel.transform.localScale = Vector3.one; var bounds = new Bounds(Vector3.zero, Vector3.zero); if (assetModel.transform.TryGetComponent\u003cRenderer\u003e(out var mainRenderer)) { bounds = mainRenderer.bounds; } var descendants = assetModel.GetComponentsInChildren\u003cTransform\u003e(); foreach (Transform desc in descendants) { if(desc.gameObject.name == \"EXCLUDE\") { continue; } if (desc.TryGetComponent\u003cRenderer\u003e(out var childRenderer)) { if (bounds.extents == Vector3.zero) bounds = childRenderer.bounds; bounds.Encapsulate(childRenderer.bounds); } } var boxCol = boxModel.AddComponent\u003cBoxCollider\u003e(); boxCol.center = bounds.center - assetModel.transform.position; boxCol.size = bounds.size; assetModel.transform.localPosition = pos; assetModel.transform.localRotation = rot; assetModel.transform.localScale = scale; return boxCol; } protected void Setup() { gameObject.layer = 6; Material green = (Material)Resources.Load(\"GREEN\", typeof(Material)); //sometimes there is one mesh if(invis.TryGetComponent(out MeshRenderer mRend)) { mRend.material = green; } //sometimes there are children meshes MeshRenderer[] MeshRenderers = invis.GetComponentsInChildren\u003cMeshRenderer\u003e(true); if(MeshRenderers.Length != 0) { foreach(MeshRenderer mRendr in MeshRenderers) { mRendr.material = green; } } //no object is held invis.SetActive(false); //SETUP LINE RENDERER line.enabled = false; line.startWidth = 0.1059608f; line.endWidth = 0.1059608f; CreateColliders(gameObject); CreateColliders(invis,1); var xrG = gameObject.AddComponent\u003cXRGrabInteractable\u003e(); xrG.throwOnDetach = false; xrG.trackRotation = false; xrG.selectEntered.AddListener(OnSelectEntered); xrG.selectExited.AddListener(OnSelectExited); xrG.movementType = XRBaseInteractable.MovementType.Instantaneous; } public virtual void SetHeld() { //if spot is valid place. if(!(spotValid \u0026\u0026 Place())) { if(initalPos != null \u0026\u0026 initalRotation != null) { //go to the inital posistion transform.position = initalPos; transform.rotation = initalRotation; } else { Destroy(this.gameObject); } } isHeld = !isHeld; ChangeDrawings(isHeld); if(isHeld) { initalPos = transform.position; initalRotation = transform.rotation; } } private bool Place() { if(!isHeld) return false; transform.position = spot; return true; } private void Rotate(float angle = 45f) { transform.rotation = transform.rotation * Quaternion.Euler(0, angle, 0); } public virtual void DrawLine() { line.SetPosition(0,transform.position); line.SetPosition(1,spot); } private void DrawInvis() { invis.transform.position = spot; } protected void DrawGuide() { DrawLine(); DrawInvis(); } void Update() { if(!isHeld) return; //check spot validity spot = grid.GetNearestValidPoint(transform.position); spotValid = grid.GetValidityPos(spot,this.gameObject.transform.position); ChangeDrawings(spotValid); if(spotValid) { DrawGuide(); } float controllerValue = leftHand.action.ReadValue\u003cVector2\u003e().x; if(Mathf.Abs(controllerValue) == 1) { Rotate(45*controllerValue); } } } ","description":"Overview Held What does a held object do Draws a line to valid spot Draws a transparent Object at valid spot Follow controller Go to spot when placed Overview of what we will do Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Object : MonoBehaviour { protected GameObject invis; protected LineRenderer line; void Awake() { line = GetComponent(); grid = GetComponent(); } public bool SetInvis(GameObject invis) { if(this."},{"id":12,"href":"/Walls/Handling-Walls.html","title":"Handling Walls","parent":"Walls","content":" Overview Walls need to take in a list of windows that are attached to the window and then cut them out of the wall so there is holes.\nWe will have a base wall which is just a solid rectangle. This will then have a child object which is the wall with any cut outs. When this child object exists then the base wall should be hidden\nOriginally I was doing this another way that was not great as it had issues with multiple models however if you are interested you can read about it here it is still useful to read about how mesh generation in unity works.\nCut wall vs base wall Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; public class Wall : MonoBehaviour { private GameObject baseWall; private MeshRenderer baseWallRend; private Collider wallCollider; private GameObject currentWall; private Collider currentWallCollider; private List\u003cWindow\u003e windows = new List\u003cWindow\u003e(); private Material mat; private float buffer = 1f; void Start() { Setup(); } private void Setup() { if(baseWall == null) { baseWall = this.gameObject; } baseWallRend = baseWall.GetComponent\u003cMeshRenderer\u003e(); currentWallCollider = wallCollider = baseWall.GetComponent\u003cCollider\u003e(); } } Handling adding and deleting windows Remember we have a List\u0026lt;Window\u0026gt; windows to store windows Foward bound is half the size of the window and is used to shift the window into the posistion of the wall so they are in line. Without this the window will not be correctly positioned in the wall.\npublic void AddWindow(Window windowScript) { GameObject window = windowScript.gameObject; float winRot = window.gameObject.transform.rotation.y; if(winRot == 0 || winRot == 1 ) { // if the window is 0 or 180 degree rotation window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z+windowScript.fowardBound[0]); } else { window.transform.position = new Vector3(window.transform.position.x+windowScript.fowardBound[1]+0.05f,window.transform.position.y,window.transform.position.z); } windows.Add(windowScript); } public void RemoveWindow(Window windowScript) { windows.Remove(windowScript); } Calculating the nearest point on a wall that is valid First we get the nearest point on the wall to the invisible indow and we then check that all the bounds of the window are within the bounds of the wall. If they are not we adjust the wall so that it fits within in these bounds. If this isn\u0026rsquo;t possible then we return our invalid vector of -0.1,-0.1,-0.1.\nWindow in a wall public Vector3 CalculateClosestPoint(GameObject window, GameObject heldWindow, Collider col) { window.SetActive(true); Vector3 startPoint = currentWallCollider.bounds.ClosestPoint(heldWindow.transform.position); window.transform.position = startPoint; float windowRot = window.transform.rotation.y; //caculate y bounds if(currentWallCollider.bounds.max.y \u0026lt; col.bounds.max.y) { window.transform.position -= new Vector3(0,(Mathf.Abs(currentWallCollider.bounds.max.y) - Mathf.Abs(col.bounds.max.y) - buffer),0); } if(currentWallCollider.bounds.min.y \u0026gt; col.bounds.min.y) { window.transform.position += new Vector3(0,(Mathf.Abs(currentWallCollider.bounds.max.y)+Mathf.Abs(col.bounds.max.y) + buffer),0); } //if its a - wall if(windowRot == 0 || windowRot == 1) { // 0 or 180 //calculate x if(currentWallCollider.bounds.max.x \u0026lt; col.bounds.max.x) { window.transform.position -= new Vector3((Mathf.Abs(currentWallCollider.bounds.max.x) - Mathf.Abs(col.bounds.max.x) - buffer),0,0); } if(currentWallCollider.bounds.min.x \u0026gt; col.bounds.min.x) { window.transform.position += new Vector3((Mathf.Abs(currentWallCollider.bounds.max.x)+Mathf.Abs(col.bounds.max.x) + buffer),0,0); } } else { //calculate z if(currentWallCollider.bounds.max.z \u0026lt; col.bounds.max.z) { window.transform.position -= new Vector3(0,0,(Mathf.Abs(currentWallCollider.bounds.max.z) - Mathf.Abs(col.bounds.max.z) - buffer)); } if(currentWallCollider.bounds.min.z \u0026gt; col.bounds.min.z) { window.transform.position += new Vector3(0,0,(Mathf.Abs(currentWallCollider.bounds.max.z)+Mathf.Abs(col.bounds.max.z) + buffer)); } if(window.transform.eulerAngles.y == 270f) { window.transform.position += new Vector3(0.05f,0,0); } else if(window.transform.eulerAngles.y == 90f) { window.transform.position += new Vector3(-0.05f,0,0); } } if(currentWallCollider.bounds.Contains(col.bounds.center) ) { window.SetActive(false); return window.transform.position; } else { window.SetActive(false); return new Vector3(-.01f,-.01f,-.01f); } } Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; public class Wall : MonoBehaviour { private GameObject baseWall; private MeshRenderer baseWallRend; private Collider wallCollider; private GameObject currentWall; private Collider currentWallCollider; private List\u003cWindow\u003e windows = new List\u003cWindow\u003e(); private Material mat; private float buffer = 1f; void Start() { Setup(); } private void Setup() { if(baseWall == null) { baseWall = this.gameObject; } baseWallRend = baseWall.GetComponent\u003cMeshRenderer\u003e(); currentWallCollider = wallCollider = baseWall.GetComponent\u003cCollider\u003e(); } public void AddWindow(Window windowScript) { GameObject window = windowScript.gameObject; float winRot = window.gameObject.transform.rotation.y; if(winRot == 0 || winRot == 1 ) { // if the window is 0 or 180 degree rotation window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z+windowScript.fowardBound[0]); } else { window.transform.position = new Vector3(window.transform.position.x+windowScript.fowardBound[1]+0.05f,window.transform.position.y,window.transform.position.z); } windows.Add(windowScript); } public void RemoveWindow(Window windowScript) { windows.Remove(windowScript); } public Vector3 CalculateClosestPoint(GameObject window, GameObject heldWindow, Collider col) { window.SetActive(true); Vector3 startPoint = currentWallCollider.bounds.ClosestPoint(heldWindow.transform.position); window.transform.position = startPoint; float windowRot = window.transform.rotation.y; //caculate y bounds if(currentWallCollider.bounds.max.y \u003c col.bounds.max.y) { window.transform.position -= new Vector3(0,(Mathf.Abs(currentWallCollider.bounds.max.y) - Mathf.Abs(col.bounds.max.y) - buffer),0); } if(currentWallCollider.bounds.min.y \u003e col.bounds.min.y) { window.transform.position += new Vector3(0,(Mathf.Abs(currentWallCollider.bounds.max.y)+Mathf.Abs(col.bounds.max.y) + buffer),0); } //if its a - wall if(windowRot == 0 || windowRot == 1) { // 0 or 180 //calculate x if(currentWallCollider.bounds.max.x \u003c col.bounds.max.x) { window.transform.position -= new Vector3((Mathf.Abs(currentWallCollider.bounds.max.x) - Mathf.Abs(col.bounds.max.x) - buffer),0,0); } if(currentWallCollider.bounds.min.x \u003e col.bounds.min.x) { window.transform.position += new Vector3((Mathf.Abs(currentWallCollider.bounds.max.x)+Mathf.Abs(col.bounds.max.x) + buffer),0,0); } } else { //calculate z if(currentWallCollider.bounds.max.z \u003c col.bounds.max.z) { window.transform.position -= new Vector3(0,0,(Mathf.Abs(currentWallCollider.bounds.max.z) - Mathf.Abs(col.bounds.max.z) - buffer)); } if(currentWallCollider.bounds.min.z \u003e col.bounds.min.z) { window.transform.position += new Vector3(0,0,(Mathf.Abs(currentWallCollider.bounds.max.z)+Mathf.Abs(col.bounds.max.z) + buffer)); } if(window.transform.eulerAngles.y == 270f) { window.transform.position += new Vector3(0.05f,0,0); } else if(window.transform.eulerAngles.y == 90f) { window.transform.position += new Vector3(-0.05f,0,0); } } if(currentWallCollider.bounds.Contains(col.bounds.center) ) { window.SetActive(false); return window.transform.position; } else { window.SetActive(false); return new Vector3(-.01f,-.01f,-.01f); } } } Cutting a single wall To cut a wall we just use CSG therefore we must add using Parabox.CSG; We then just pass in both the objects and it will do the hard lifting for us:\nprivate GameObject CutWall(GameObject wall, Window windowScript) { GameObject window = windowScript.gameObject; Model result = CSG.Subtract(wall,windowScript.MeshObject); GameObject newWall = new GameObject(); newWall.AddComponent\u0026lt;MeshFilter\u0026gt;().sharedMesh = result.mesh; newWall.AddComponent\u0026lt;MeshRenderer\u0026gt;().sharedMaterials = result.materials.ToArray(); return newWall; } Our problem now is that we aren\u0026rsquo;t properly lining up so we need to add some code to fix that\nprivate GameObject CutWall(GameObject wall, Window windowScript) { GameObject window = windowScript.gameObject; float wallRot = wall.transform.rotation.y; //we need to take away the offset so it cuts properly if(wallRot == 0 || wallRot == 1) { window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z-windowScript.fowardBound[0]); } else { // VERTICAL WALL window.transform.position = new Vector3(window.transform.position.x-windowScript.fowardBound[1],window.transform.position.y,window.transform.position.z); } Model result = CSG.Subtract(wall,windowScript.MeshObject); GameObject newWall = new GameObject(); newWall.AddComponent\u0026lt;MeshFilter\u0026gt;().sharedMesh = result.mesh; newWall.AddComponent\u0026lt;MeshRenderer\u0026gt;().sharedMaterials = result.materials.ToArray(); //add back the offset if(wallRot == 0) { window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z+windowScript.fowardBound[0]); } else if(wallRot == 1 /*180degrees*/ ) { window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z-windowScript.fowardBound[0]); } else if(wall.transform.eulerAngles.y == 90){ window.transform.position = new Vector3(window.transform.position.x-windowScript.gameObject.GetComponent\u0026lt;Collider\u0026gt;().bounds.size.x/2,window.transform.position.y,window.transform.position.z); } return newWall; } We then have to handle all the walls as this only handles one:\nprivate GameObject CutWalls() { GameObject returnWall = baseWall; //wall to be destroyed GameObject destroyWall = null; foreach(Window window in windows) { //we don\u0026#39;t want to destory the base wall if(returnWall != baseWall) { destroyWall = returnWall; } returnWall = CutWall(returnWall,window); if(destroyWall != null) { //destory the old wall so only the new cut remains Destroy(destroyWall); } } return returnWall; // return new wall } We then should handle making the base wall not show and only have the cut wall appaear.\nprivate void HandleCutting() { if(currentWall != null \u0026amp;\u0026amp; currentWall != baseWall) { Destroy(currentWall); } currentWall = CutWalls(); currentWall.transform.parent = this.gameObject.transform; if(currentWall != baseWall) { //set up the new wall baseWallRend.enabled = false; wallCollider.enabled = false; MeshCollider newCol = currentWall.AddComponent\u0026lt;MeshCollider\u0026gt;(); newCol.sharedMesh = currentWall.GetComponent\u0026lt;MeshFilter\u0026gt;().mesh; currentWallCollider = newCol; currentWall.layer = 7; } else { //base wall currentWallCollider = wallCollider; baseWallRend.enabled = true; wallCollider.enabled = true; } } public void Cut() { HandleCutting(); } Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; using Parabox.CSG; public class Wall : MonoBehaviour { [SerializeField] private GameObject baseWall; private MeshRenderer baseWallRend; private Collider wallCollider; [SerializeField] private GameObject currentWall; [SerializeField] private Collider currentWallCollider; private Window currentWallScript; [SerializeField] private List\u003cWindow\u003e windows = new List\u003cWindow\u003e(); private Material mat; private float buffer = 1f; private GameObject CutWall(GameObject wall, Window windowScript) { GameObject window = windowScript.gameObject; float wallRot = wall.transform.rotation.y; if(wallRot == 0 || wallRot == 1) { window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z-windowScript.fowardBound[0]); } else { // VERTICAL WALL window.transform.position = new Vector3(window.transform.position.x-windowScript.fowardBound[1],window.transform.position.y,window.transform.position.z); } Model result = CSG.Subtract(wall,windowScript.MeshObject); GameObject newWall = new GameObject(); newWall.AddComponent\u003cMeshFilter\u003e().sharedMesh = result.mesh; newWall.AddComponent\u003cMeshRenderer\u003e().sharedMaterials = result.materials.ToArray(); if(wallRot == 0) { window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z+windowScript.fowardBound[0]); } else if(wallRot == 1 /*180degrees*/ ) { window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z-windowScript.fowardBound[0]); } else if(wall.transform.eulerAngles.y == 90){ window.transform.position = new Vector3(window.transform.position.x-windowScript.gameObject.GetComponent\u003cCollider\u003e().bounds.size.x/2,window.transform.position.y,window.transform.position.z); } return newWall; } private GameObject CutWalls() { GameObject returnWall = baseWall; GameObject destroyWall = null; foreach(Window window in windows) { if(returnWall != baseWall) { destroyWall = returnWall; } returnWall = CutWall(returnWall,window); if(destroyWall != null) { Destroy(destroyWall); } } return returnWall; } void Start() { Setup(); } private void Setup() { if(baseWall == null) { baseWall = this.gameObject; } baseWallRend = baseWall.GetComponent\u003cMeshRenderer\u003e(); currentWallCollider = wallCollider = baseWall.GetComponent\u003cCollider\u003e(); } private void HandleCutting() { if(currentWall != null \u0026\u0026 currentWall != baseWall) { Destroy(currentWall); } currentWall = CutWalls(); currentWall.transform.parent = this.gameObject.transform; if(currentWall != baseWall) { baseWallRend.enabled = false; wallCollider.enabled = false; MeshCollider newCol = currentWall.AddComponent\u003cMeshCollider\u003e(); newCol.sharedMesh = currentWall.GetComponent\u003cMeshFilter\u003e().mesh; currentWallCollider = newCol; currentWall.layer = 7; } else { currentWallCollider = wallCollider; baseWallRend.enabled = true; wallCollider.enabled = true; } } //probably should be using an empty game object instead of the invis object. public Vector3 CalculateClosestPoint(GameObject window, GameObject heldWindow, Collider col) { window.SetActive(true); Vector3 startPoint = currentWallCollider.bounds.ClosestPoint(heldWindow.transform.position); window.transform.position = startPoint; float windowRot = window.transform.rotation.y; //caculate y bounds if(currentWallCollider.bounds.max.y \u003c col.bounds.max.y) { window.transform.position -= new Vector3(0,(Mathf.Abs(currentWallCollider.bounds.max.y) - Mathf.Abs(col.bounds.max.y) - buffer),0); } if(currentWallCollider.bounds.min.y \u003e col.bounds.min.y) { window.transform.position += new Vector3(0,(Mathf.Abs(currentWallCollider.bounds.max.y)+Mathf.Abs(col.bounds.max.y) + buffer),0); } //if its a - wall if(windowRot == 0 || windowRot == 1) { //calculate x if(currentWallCollider.bounds.max.x \u003c col.bounds.max.x) { window.transform.position -= new Vector3((Mathf.Abs(currentWallCollider.bounds.max.x) - Mathf.Abs(col.bounds.max.x) - buffer),0,0); } if(currentWallCollider.bounds.min.x \u003e col.bounds.min.x) { window.transform.position += new Vector3((Mathf.Abs(currentWallCollider.bounds.max.x)+Mathf.Abs(col.bounds.max.x) + buffer),0,0); } } else { //calculate z if(currentWallCollider.bounds.max.z \u003c col.bounds.max.z) { window.transform.position -= new Vector3(0,0,(Mathf.Abs(currentWallCollider.bounds.max.z) - Mathf.Abs(col.bounds.max.z) - buffer)); } if(currentWallCollider.bounds.min.z \u003e col.bounds.min.z) { window.transform.position += new Vector3(0,0,(Mathf.Abs(currentWallCollider.bounds.max.z)+Mathf.Abs(col.bounds.max.z) + buffer)); } if(window.transform.eulerAngles.y == 270f) { window.transform.position += new Vector3(0.05f,0,0); } else if(window.transform.eulerAngles.y == 90f) { window.transform.position += new Vector3(-0.05f,0,0); } } if(currentWallCollider.bounds.Contains(col.bounds.center) ) { window.SetActive(false); return window.transform.position; } else { window.SetActive(false); return new Vector3(-.01f,-.01f,-.01f); } } public void AddWindow(Window windowScript) { GameObject window = windowScript.gameObject; float winRot = window.gameObject.transform.rotation.y; if(winRot == 0 || winRot == 1 ) { window.transform.position = new Vector3(window.transform.position.x,window.transform.position.y,window.transform.position.z+windowScript.fowardBound[0]); } else { window.transform.position = new Vector3(window.transform.position.x+windowScript.fowardBound[1]+0.05f,window.transform.position.y,window.transform.position.z); } windows.Add(windowScript); } public void RemoveWindow(Window windowScript) { windows.Remove(windowScript); } public void Cut() { HandleCutting(); } } ","description":"Overview Walls need to take in a list of windows that are attached to the window and then cut them out of the wall so there is holes.\nWe will have a base wall which is just a solid rectangle. This will then have a child object which is the wall with any cut outs. When this child object exists then the base wall should be hidden\nOriginally I was doing this another way that was not great as it had issues with multiple models however if you are interested you can read about it here it is still useful to read about how mesh generation in unity works."},{"id":13,"href":"/Objects/Imported-Models-to-Objects.html","title":"Imported Models to Objects","parent":"Unity Setup","content":" Overview We have this code for importing models:\nusing System.Collections; using System.Collections.Generic; using System.IO; using System; using UnityEngine; using GLTFast; public class Importer : MonoBehaviour { void ImportAll() { if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \u0026#34;*.glb\u0026#34;); foreach(string file in files) { Import(file.Split(\u0026#34;/\u0026#34;)[^1].Split(\u0026#34;.\u0026#34;)[0]); } } } public async void Import(String file) { byte[] data = File.ReadAllBytes($\u0026#34;{dirPath}{file}.glb\u0026#34;); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file).transform; success = await gltf.InstantiateMainSceneAsync( placedModel ); } } } And if we look to objects for what we need to do we need to:\nAdd the object script Add an invis object with the same meshes as the parent one Set this invis object to an invis reference in the main object script Set the left handed reference This needs set in the inspector:\npublic InputActionReference leftHand; and also we need to:\nusing UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; We then just add the component and set the details of it:\npublic async void Import(String file) { byte[] data = File.ReadAllBytes($\u0026#34;{dirPath}{file}.glb\u0026#34;); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file).transform; success = await gltf.InstantiateMainSceneAsync( placedModel ); if(success) { GameObject invis = Instantiate(placedModel.gameObject,placedModel.gameObject.transform); invis.gameObject.name = \u0026#34;Invis\u0026#34;; Object comp = placedModel.gameObject.AddComponent\u0026lt;Object\u0026gt;(); comp.SetDetails(new ObjectDetails(name,description,type)); comp.SetInvis(invis); comp.leftHand = leftHand; } } } Current Progress ... using System.Collections; using System.Collections.Generic; using System.IO; using System; using UnityEngine; using GLTFast; using UnityEngine.InputSystem; using UnityEngine.XR.Interaction.Toolkit; public class Importer : MonoBehaviour { void ImportAll() { if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \"*.glb\"); foreach(string file in files) { Import(file.Split(\"/\")[^1].Split(\".\")[0]); } } } public async void Import(String file) { byte[] data = File.ReadAllBytes($\"{dirPath}{file}.glb\"); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file).transform; success = await gltf.InstantiateMainSceneAsync( placedModel ); if(success) { GameObject invis = Instantiate(placedModel.gameObject,placedModel.gameObject.transform); invis.gameObject.name = \"Invis\"; Object comp = placedModel.gameObject.AddComponent\u003cObject\u003e(); comp.SetDetails(new ObjectDetails(name,description,type)); comp.SetInvis(invis); comp.leftHand = leftHand; } } } } ","description":"Overview We have this code for importing models:\nusing System.Collections; using System.Collections.Generic; using System.IO; using System; using UnityEngine; using GLTFast; public class Importer : MonoBehaviour { void ImportAll() { if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \u0026#34;*.glb\u0026#34;); foreach(string file in files) { Import(file.Split(\u0026#34;/\u0026#34;)[^1].Split(\u0026#34;.\u0026#34;)[0]); } } } public async void Import(String file) { byte[] data = File.ReadAllBytes($\u0026#34;{dirPath}{file}.glb\u0026#34;); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file)."},{"id":14,"href":"/Objects/Importing-Models.html","title":"Importing Models","parent":"Unity Setup","content":" Importing Models with glTFast We are going to use glTFast for importing models into the game.\nWe\u0026rsquo;ll make a script called Importer and add using glTFast to the namespace.\nWe should also define a string that is the file directory that the models are in by default we will set it to:\nprivate string dirPath = $\u0026#34;C:/Users/{Environment.UserName}/Downloads/models/\u0026#34;; But this should be able to be changed by the player.\nWe are going to need add these for the script:\nusing System.Collections; using System.Collections.Generic; using System.IO; using System; using UnityEngine; using GLTFast; The first thing we need to implement is importing an object:\npublic async void Import(String file) { byte[] data = File.ReadAllBytes($\u0026#34;{dirPath}{file}.glb\u0026#34;); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file).transform; success = await gltf.InstantiateMainSceneAsync( placedModel ); } } This will import an model you can read more about importing meshss here: glTFast documentation\nWe next should write add a method for importing a directory of meshes. Let\u0026rsquo;s define the method:\nvoid ImportAll() { } We first should be check if the dirPath exists:\nif(System.IO.Directory.Exists(dirPath)) { } and if it does we can then proceed to get all .glb files in the directory\nif(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \u0026#34;*.glb\u0026#34;); } We then need to import all of these:\nif(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \u0026#34;*.glb\u0026#34;); foreach(string file in files) { Import(file.Split(\u0026#34;/\u0026#34;)[^1].Split(\u0026#34;.\u0026#34;)[0]); } } This line is for extracting a filename from a filepath that includes both a path and a file extension:\n.Split(\u0026#34;/\u0026#34;)[^1].Split(\u0026#34;.\u0026#34;)[0] Explanation ... E.G: /picture.png\n.Split(\"/\") we split the input string by the forward slash “/” character, which is how directories and filenames in file paths are separated.\n[^1] This selects the last element of the array created by the previous step. Since the file name is usually the last segment of a filepath, this effectively extracts the filename from the input string.\nE.G: picture.png\n.Split(\".\") This then splits it by the . for the exentsion.\n[0] Select the file name part not the file type\nE.G: picture\nAll together this becomes:\nvoid ImportAll() { if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \u0026#34;*.glb\u0026#34;); foreach(string file in files) { Import(file.Split(\u0026#34;/\u0026#34;)[^1].Split(\u0026#34;.\u0026#34;)[0]); } } } We can then call ImportAll() to import all the models in a given directory.\nCurrent Progress ... using System.Collections; using System.Collections.Generic; using System.IO; using System; using UnityEngine; using GLTFast; public class Importer : MonoBehaviour { void ImportAll() { if(System.IO.Directory.Exists(dirPath)) { string[] files = System.IO.Directory.GetFiles(dirPath, \"*.glb\"); foreach(string file in files) { Import(file.Split(\"/\")[^1].Split(\".\")[0]); } } } public async void Import(String file) { byte[] data = File.ReadAllBytes($\"{dirPath}{file}.glb\"); GltfImport gltf = new GltfImport(); bool success = await gltf.LoadGltfBinary(data); if (success) { Transform placedModel = new GameObject(file).transform; success = await gltf.InstantiateMainSceneAsync( placedModel ); } } } ","description":"Importing Models with glTFast We are going to use glTFast for importing models into the game.\nWe\u0026rsquo;ll make a script called Importer and add using glTFast to the namespace.\nWe should also define a string that is the file directory that the models are in by default we will set it to:\nprivate string dirPath = $\u0026#34;C:/Users/{Environment.UserName}/Downloads/models/\u0026#34;; But this should be able to be changed by the player.\nWe are going to need add these for the script:"},{"id":15,"href":"/tags.html","title":"Tags","parent":"","content":"","description":""},{"id":16,"href":"/Objects.html","title":"Unity Setup","parent":"","content":" Overview Objects can be held and will be placed on a grid system inspired by the sims. They will be dynamically loaded in using gLTFast. This means we need to implement a grid system; dynamically loading meshes; making colliders at runtime; reading from the file system.\n","description":"Overview Objects can be held and will be placed on a grid system inspired by the sims. They will be dynamically loaded in using gLTFast. This means we need to implement a grid system; dynamically loading meshes; making colliders at runtime; reading from the file system."},{"id":17,"href":"/Unity-Setup.html","title":"Unity Setup","parent":"","content":"Use the 3d URP template.\n3D URP We then should set up the layers in project settings.\nLayer Name 6 Object 7 Wall 31 Teleport Project settings - layers ","description":"Use the 3d URP template.\n3D URP We then should set up the layers in project settings.\nLayer Name 6 Object 7 Wall 31 Teleport Project settings - layers "},{"id":18,"href":"/User-Interface/User-Interface-Setup.html","title":"User Interface Setup","parent":"User Interface","content":" Overview We need to make a button with text of the model that we are going to import and then we should lay this out in a scroll view.\nWe can make a button using the Action Button prefab provided by MRTK3.\nUI Setup All we do is for every model in the directory we make a button with the title of the file.\nusing System.Collections; using System.Collections.Generic; using UnityEngine; public class ImportUI : MonoBehaviour { [SerializeField] private GameObject actionButton; private Importer importer; void Start() { importer = GameObject.Find(\u0026#34;importer\u0026#34;).GetComponent\u0026lt;Importer\u0026gt;(); Populate(); } void Populate() { if(importer == null) { Debug.LogError(\u0026#34;no importer found.\u0026#34;); return; } if(actionButton == null) { Debug.LogError(\u0026#34;no actionButton found.\u0026#34;); return; } foreach(string model in importer.GetAllFiles()) { GameObject button = Instantiate(actionButton,gameObject.transform); } } } We now need to handle logic for buttons\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using Microsoft.MixedReality.Toolkit.UX; using UnityEngine.XR.Interaction.Toolkit; using TMPro; public class ButtonImporter : MonoBehaviour { Importer importer; string model; void Start() { //get the action button press component and add a listener so we can use it PressableButton buttonScript = gameObject.GetComponent\u0026lt;PressableButton\u0026gt;(); buttonScript.selectEntered.AddListener(OnSelectEntered); } //setup the button\u0026#39;s visuals public void Setup(Importer importer, string model) { this.importer = importer; this.model = model; GameObject text = this.gameObject.transform.Find(\u0026#34;Frontplate/AnimatedContent/Text\u0026#34;).gameObject; TMP_Text textComp = text.GetComponent\u0026lt;TMP_Text\u0026gt;(); textComp.text = model; textComp.fontSize = 10; text.SetActive(true); } void Import() { importer.Import(model); } protected virtual void OnSelectEntered(SelectEnterEventArgs args) =\u0026gt; Import(); } Now we have a Setup() method that can be called in the for loop of the ImportUI class.\nButtonImporter buttonScript = button.AddComponent\u0026lt;ButtonImporter\u0026gt;(); buttonScript.Setup(importer,model); Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; public class ImportUI : MonoBehaviour { [SerializeField] private GameObject actionButton; private Importer importer; void Start() { importer = GameObject.Find(\"importer\").GetComponent\u003cImporter\u003e(); Populate(); } void Populate() { if(importer == null) { Debug.LogError(\"no importer found.\"); return; } if(actionButton == null) { Debug.LogError(\"no actionButton found.\"); return; } foreach(string model in importer.GetAllFiles()) { GameObject button = Instantiate(actionButton,gameObject.transform); ButtonImporter buttonScript = button.AddComponent\u003cButtonImporter\u003e(); buttonScript.Setup(importer,model); } } } Current Progress ... using System.Collections; using System.Collections.Generic; using UnityEngine; using Microsoft.MixedReality.Toolkit.UX; using UnityEngine.XR.Interaction.Toolkit; using TMPro; public class ButtonImporter : MonoBehaviour { Importer importer; string model; void Start() { //get the action button press component and add a listener so we can use it PressableButton buttonScript = gameObject.GetComponent\u003cPressableButton\u003e(); buttonScript.selectEntered.AddListener(OnSelectEntered); } //setup the button's visuals public void Setup(Importer importer, string model) { this.importer = importer; this.model = model; GameObject text = this.gameObject.transform.Find(\"Frontplate/AnimatedContent/Text\").gameObject; TMP_Text textComp = text.GetComponent\u003cTMP_Text\u003e(); textComp.text = model; textComp.fontSize = 10; text.SetActive(true); } void Import() { importer.Import(model); } protected virtual void OnSelectEntered(SelectEnterEventArgs args) =\u003e Import(); } Ingame Setup Create a canvas with a scroll view:\nHow the hierachy should be In the content object add the ImportUI component and add a reference to the action button (found under Packages/MRTK UX Components/Button/Prefabs/):\nHow the content should look This will then load all the files in the directory into a scroll view.\n","description":"Overview We need to make a button with text of the model that we are going to import and then we should lay this out in a scroll view.\nWe can make a button using the Action Button prefab provided by MRTK3.\nUI Setup All we do is for every model in the directory we make a button with the title of the file.\nusing System.Collections; using System.Collections.Generic; using UnityEngine; public class ImportUI : MonoBehaviour { [SerializeField] private GameObject actionButton; private Importer importer; void Start() { importer = GameObject."},{"id":19,"href":"/VR/VR-Movement.html","title":"VR Movement","parent":"VR Overview","content":" Setting up teleportation Add a Locomotion System to the MRTK XR Rig (under XR)\ncreating locomotive system Once added add a Input action reference (found under /Packages/MRTK Input/Assets/Input Actions/) to the reference section in the inspector.\ninteractables adding locomotive system You should now be able to move around with the trigger button to teleport and the input action reference to snap turn.\n","description":"Setting up teleportation Add a Locomotion System to the MRTK XR Rig (under XR)\ncreating locomotive system Once added add a Input action reference (found under /Packages/MRTK Input/Assets/Input Actions/) to the reference section in the inspector.\ninteractables adding locomotive system You should now be able to move around with the trigger button to teleport and the input action reference to snap turn."},{"id":20,"href":"/VR.html","title":"VR Overview","parent":"","content":" Overview We are going to be using MRTK3 for handling VR interactions. This is a microsoft devloped framework that is an abstraction upon the XR framework and works for the vast majority of vr devices. It also contains some useful components that will help speed up development.\n","description":"Overview We are going to be using MRTK3 for handling VR interactions. This is a microsoft devloped framework that is an abstraction upon the XR framework and works for the vast majority of vr devices. It also contains some useful components that will help speed up development."},{"id":21,"href":"/VR/VR-Setup.html","title":"VR Setup","parent":"VR Overview","content":" Installing MRTK3 The first thing we need to do is install the Microsoft Mixed Reality Feature Tool. Once we have this installed we can run it. We can then direct it to the base folder of our base unity project\nSelecting directory of mixed reality feature tool Once selected we then need to install all the MRTK3 Features and install Mixed Reality OpenXR Plugin under the Platform Support and click import: we now have MRTK3 installed and we should now focus on setting up the vr project.\nCaution ERRORS\nIt is possible that you may get errors after installing MRTK3 that you may have to solve yourself as they are not replicable and I have not experienced them; normally MRTK3 gives instructions on how to solve so you should be able to fix them. Setting up MRTK3 Go to Project Settings and under XR Plug-in Management select:\nSelecting openxr Then add the MRTK XR Rig prefab to the scene which is under Packages/MRTK Input/Assets/Prefabs/MRTK XR Rig\nYou should then test with a vr headset that the project is running and you are able to look around.\n","description":"Installing MRTK3 The first thing we need to do is install the Microsoft Mixed Reality Feature Tool. Once we have this installed we can run it. We can then direct it to the base folder of our base unity project\nSelecting directory of mixed reality feature tool Once selected we then need to install all the MRTK3 Features and install Mixed Reality OpenXR Plugin under the Platform Support and click import: we now have MRTK3 installed and we should now focus on setting up the vr project."}]